#' Calculate station bottom temperature and salinity
#' 
#' Use the OCE package to retrieve CTD bottom data from cnv files and calculate mean temperature and salinity. Run after haul events have been populated to metadata and before calc_surface_mean().
#' 
#' @param haul_metadata_path Character vector. Path to haul data .csv generated by get_bottom_data().
#' @param pattern Character vector. Suffix of cnv file to search for. Default = "TEOS10.cnv"
#' @param timezone Timezone as a character vector to force instrument time. Default = "America/Anchorage" to correspond with survey time.
#' @param time_buffer 1L numeric vector. Buffer between on-bottom/off-bottom events and first/last data point to use to calculate bottom values, in seconds.
#' @param append_haul_metadata Logical. Should the file named in haul_metadata_path be appended (overwritten) to include mean bottom values and metadata?
#' @export

calc_bottom_mean <- function(haul_metadata_path = list.files(paste0(getwd(), "/metadata/"), full.names = TRUE),
                             pattern = "TEOS10.cnv",
                             timezone = "America/Anchorage",
                             time_buffer = 30,
                             append_haul_metadata = TRUE) {
  
  if(length(haul_metadata_path) != 1) {
    stop(paste("get_haul_events(): Argument haul_meta_data path must only be file but has length ", length(haul_metadata_path)))
  }
  
  # Load haul metadata file
  haul_metadata <- read.csv(file = haul_metadata_path, 
                            stringsAsFactors = FALSE)
  
  out_df <- haul_metadata
  
  # Extract bottom data from each haul
  for(i in 1:nrow(haul_metadata)) {
    
    if(i%%50 == 0) {
      print(paste0("Calculating bottom values from file ", i, " out of ", nrow(haul_metadata)))
    }
    
    fpath <- list.files(here::here("cnv"), pattern = sub("\\_raw.*", "", haul_metadata$cnv_file_name[i]), 
                        full.names = TRUE)
    fpath <- fpath[grepl(pattern = pattern, fpath, fixed = TRUE)]
    
    # Get cast_start time
    cast_dat <- suppressWarnings(try(oce::read.ctd.sbe(file = fpath), silent = TRUE))
    
    if(class(cast_dat) == "try-error") {
      
      warning("try-error in ", fpath)
      
      out_df$CTD_MEAN_HAUL_DEPTH[i] <- NA
      out_df$CTD_MEAN_BOTTOM_TEMPERATURE_C[i] <- NA
      out_df$CTD_MEAN_BOTTOM_SALINITY_SA[i] <- NA
      out_df$CTD_MEAN_BOTTOM_SALINITY_SP[i] <- NA
      out_df$CTD_MEAN_BOTTOM_SOUNDSPEED[i] <- NA
      out_df$CTD_N_BOTTOM_SAMPLE[i] <- NA
      out_df$CTD_CALIBRATION_DATE[i] <- NA
      out_df$CTD_SERIAL_NUMBER[i] <- NA
      out_df$CTD_CAST_START[i] <- NA
      out_df$DOWNCAST_END_SECONDS[i] <- NA
      out_df$DOWNCAST_END_INDEX[i] <- NA
      out_df$UPCAST_START_SECONDS[i] <- NA
      out_df$UPCAST_START_INDEX[i] <- NA
      
      next
    }
    
    cast_start <- as.POSIXct(cast_dat@metadata$startTime)
    cast_start <- lubridate::force_tz(cast_start, tzone = timezone)
    
    sample_interval <- cast_dat@metadata$sampleInterval
    
    start_index <- (difftime(as.POSIXct(haul_metadata$ON_BOTTOM[i]) |> 
                               lubridate::force_tz(tzone = timezone), 
                             cast_start + time_buffer,
                             units = "secs") / sample_interval) |>
      as.numeric()
    
    end_index <- (difftime(as.POSIXct(haul_metadata$HAULBACK[i]) |> 
                             lubridate::force_tz(tzone = timezone), 
                           cast_start - time_buffer,
                           units = "secs") / sample_interval) |>
      as.numeric()
    
    if(!is.na(start_index) & !is.na(end_index)) {
      
      # Calibration date
      calibration_date <- cast_dat@metadata$header[which(grepl(pattern = "CalibrationDate", cast_dat@metadata$header))]
      calibration_date <- gsub(pattern = ".*<CalibrationDate>", "", calibration_date)
      calibration_date <- gsub(pattern = "</CalibrationDate>.*", "", calibration_date)
      
      
      serial_number <- cast_dat@metadata$header[which(grepl(pattern = "<SerialNumber>", cast_dat@metadata$header))]
      serial_number <- gsub(pattern = ".*<SerialNumber>", "", serial_number)
      serial_number <- gsub(pattern = "</SerialNumber>.*", "", serial_number)
      
      
      out_df$CTD_MEAN_HAUL_DEPTH[i] <- mean(cast_dat@data$depth[start_index:end_index], na.rm = TRUE)
      out_df$CTD_MEAN_BOTTOM_TEMPERATURE_C[i] <- mean(cast_dat@data$temperature[start_index:end_index], na.rm = TRUE)
      out_df$CTD_MEAN_BOTTOM_SALINITY_SA[i] <- mean(cast_dat@data$gsw_saA0[start_index:end_index], na.rm = TRUE)
      out_df$CTD_MEAN_BOTTOM_SALINITY_SP[i] <- mean(cast_dat@data$salinity[start_index:end_index], na.rm = TRUE)
      out_df$CTD_MEAN_BOTTOM_SOUNDSPEED[i] <- mean(cast_dat@data$soundSpeed[start_index:end_index], na.rm = TRUE)
      out_df$CTD_N_BOTTOM_SAMPLE[i] <- end_index - start_index + 1
      out_df$CTD_CALIBRATION_DATE[i] <- calibration_date[1]
      out_df$CTD_SERIAL_NUMBER[i] <- serial_number[1]
      out_df$CTD_CAST_START[i] <- as.character(cast_start)
      out_df$DOWNCAST_END_SECONDS[i] <- cast_dat@data$timeS[start_index] # Downcast end time in seconds elapsed
      out_df$DOWNCAST_END_INDEX[i] <- start_index
      out_df$UPCAST_START_SECONDS[i] <- cast_dat@data$timeS[end_index] # Upcast start time in seconds elapsed
      out_df$UPCAST_START_INDEX[i] <- end_index
    }
    
  }
  
  # Handle cases that don't correspond with hauls
  out_df$DOWNCAST_END_SECONDS[out_df$DOWNCAST_END_SECONDS <= 0] <- NA
  out_df$UPCAST_START_SECONDS[out_df$UPCAST_START_SECONDS <= 0] <- NA
  out_df$DOWNCAST_END_INDEX[is.na(out_df$DOWNCAST_END_SECONDS)] <- NA
  out_df$UPCAST_START_INDEX[is.na(out_df$UPCAST_START_SECONDS)] <- NA
  
  
  if(append_haul_metadata) {
    write.csv(x = out_df, 
              file = haul_metadata_path, 
              row.names = FALSE)
  }
  
  return(out_df)
  
}