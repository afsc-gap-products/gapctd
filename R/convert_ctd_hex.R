#' Convert hex files using SBE Data Processing software
#' 
#'  Converts .hex files to .cnv files using SBE Data Processing. Must have SBE Data Processing software installed for this function to work.
#'  
#'  @param ctd_directory_path Path to CTD directory
#'  @param xmlcon_path Path to xmlcon file
#'  @export

convert_ctd_hex <- function(ctd_directory_path, 
                            xmlcon_path, 
                            bat_file = NULL, 
                            datcnv_file = NULL) {
  
  if(is.null(bat_file)) {
    bat_file <- system.file("extdata/atsea/atsea_getdata.bat", package = "gapctd")    
  }
  
  if(is.null(datcnv_file)) {
    datcnv_file <- system.file("extdata/atsea/DatCnv.psa", package = "gapctd")
  }
  
  if(!dir.exists(paste0(getwd(), "/output"))) {
    dir.create(paste0(getwd(), "/output"))
  }
  
  if(!dir.exists(paste0(getwd(), "/data"))) {
    dir.create(paste0(getwd(), "/data"))
  }
  
  # Generate list of files
  hex_file_paths <- list.files(path = ctd_directory_path, 
                               pattern = ".hex",
                               full.names = TRUE)
  
  file.copy(from = hex_file_paths,
            to = gsub(pattern = ctd_directory_path, 
                      replacement = paste0(getwd(), "/data"),
                      x = hex_file_paths))
  
  # Run batch processing to generate raw .cnv files
  system(command = paste0("sbebatch ", 
                          bat_file, " ", 
                          getwd(), " ", 
                          datcnv_file, " ",
                          xmlcon_path))
}



#' Convert SBE19plus V2 hex files to cnv without SBE Data Processing
#' 
#' This function decodes hexadecimal-formatted files that are generated by SeaTerm software then writes converted data to cnv files. Output files are similar to the output of SBE Data Processing software and can be read into R using oce::read.ctd().
#' 
#' @param hex_path Path to a .hex file
#' @param output_path Path to the output file location for a .cnv file
#' @param sample_interval Sampling interval for scans; 0.25 for a typical SBE19plus V2 deployment.
#' @param output_channels Named vector of output channels and their names. Do not change from default unless additional channels of data are added.
#' @param output_sig_digits Significant digits after the decimal place for output channels. Do not change from default unless additional channels of data are added or sensor precision changes.
#' @export

hex_to_cnv <- function(hex_path, 
                       output_path, 
                       sample_interval = 0.25, 
                       output_channels = c("time_elapsed" = "timeS: Time, Elapsed [seconds]",
                                           "temperature" = "tv290C: Temperature [ITS-90, deg C]",
                                           "pressure" = "prdM: Pressure, Strain Gauge [db]",
                                           "conductivity" = "c0S/m: Conductivity [S/m]", 
                                           "flag" = "flag:  0.000e+00"),
                       output_sig_digits = c("time_elapsed" = 3,
                                             "temperature" = 4,
                                             "pressure" = 3,
                                             "conductivity" = 6, 
                                             "flag" = 1)) {
  
  # Split-up hex file into header and hex data
  lines_hex <- readr::read_lines(hex_path)
  end_header <- grep(pattern = "*END*", x = lines_hex)
  last_line <- length(lines_hex)
  lines_header <- lines_hex[1:(end_header-1)]
  lines_data <- lines_hex[(end_header+1):(last_line-1)]
  lines_raw <- purrr::map(lines_data, .f = gapctd:::hex_line_to_raw)
  
  # Index of hex values for different channels
  cols <- tibble::tibble(
    start = c(1, 4, 7, 10),
    size = diff(c(start, 12)),
    big_endian = c(rep(TRUE, 4)),
    name = c("temperature_int", "conductivity_int", "pressure_int", "tvoltage_int")
  )
  
  # Add list of bytes to a tbl
  lines_tbl <- tibble::tibble(
    lines_hex = lines_data,
    lines_raw = lines_raw,
    scan = seq_along(lines_raw),
    pos = purrr::map(lines_raw, seq_along)
  )
  
  # Split list based on hex index
  values_int <- lines_tbl %>%
    dplyr::select(scan, lines_raw) %>% 
    tidyr::unnest(lines_raw) %>% 
    dplyr::group_by(scan) %>% 
    dplyr::summarise(gapctd:::hex_extract_raw_uint_tbl(lines_raw, cols = cols))
  
  
  # Temperature calibration coefficients from header
  
  cal_par_names <- c("TA0", "TA1", "TA2", "TA3", "TOFFSET", "G", "H", "I", "J", "CPCOR", "CTCOR", "CSLOPE", "PA0", "PA1", "PA2", "PTEMPA0", "PTEMPA1", "PTEMPA2", "PTCA0", "PTCA1", "PTCA2", "PTCB0", "PTCB1", "PTCB2", "POFFSET")
  
  cal_par_list <- list()
  
  for(ii in 1:length(cal_par_names)) {
    cal_par_list[[cal_par_names[ii]]] <- gapctd:::get_calibration_parameter(header = lines_header, cal_par = cal_par_names[ii])
  }
  
  # Test conversion ----
  
  temperature  <- gapctd:::integer_to_temperature(
    temperature_integer = values_int$temperature_int,
    sig_figs = 4,
    a0 = cal_par_list[['TA0']],
    a1 = cal_par_list[['TA1']],
    a2 = cal_par_list[['TA2']],
    a3 = cal_par_list[['TA3']]
  )
  
  pressure <- gapctd:::integer_to_pressure(
    pressure_integer = values_int$pressure_int,
    temperature_integer = values_int$temperature_int,
    tvoltage_integer = values_int$tvoltage_int,
    ptempa0 = cal_par_list[['PTEMPA0']],
    ptempa1 = cal_par_list[['PTEMPA1']],
    ptempa2 = cal_par_list[['PTEMPA2']],
    ptca0 = cal_par_list[['PTCA0']],
    ptca1 = cal_par_list[['PTCA1']],
    ptca2 = cal_par_list[['PTCA2']],
    ptcb0 = cal_par_list[['PTCB0']],
    ptcb1 = cal_par_list[['PTCB1']],
    ptcb2 = cal_par_list[['PTCB2']],
    pa0 = cal_par_list[['PA0']],
    pa1 = cal_par_list[['PA1']],
    pa2 = cal_par_list[['PA2']],
    sig_figs = 3,
    convert_to_dbar = TRUE
  )
  
  
  conductivity <- gapctd:::integer_to_conductivity(
    conductivity_integer = values_int$conductivity_int,
    temperature = temperature,
    pressure = pressure, 
    condg = cal_par_list[['G']], 
    condh = cal_par_list[['H']], 
    condi = cal_par_list[['I']], 
    condj = cal_par_list[['J']], 
    cpcor = cal_par_list[['CPCOR']], 
    ctcor = cal_par_list[['CTCOR']],
    par0 = 256,
    par1 = 1000.0, 
    sig_figs = 6
  )
  
  time_elapsed <- seq(0, (length(lines_data)-1)*sample_interval, sample_interval)
  flag <- rep(0, length(lines_data))
  
  cnv_dat <- list(
    data = data.frame(
      conductivity = conductivity, 
      temperature = temperature, 
      pressure = pressure,
      time_elapsed = time_elapsed,
      flag = flag
    ),
    hex_path = hex_path,
    sample_interval = sample_interval,
    cal_par_list = cal_par_list,
    header = lines_header,
    output_channels = output_channels,
    output_sig_digits = output_sig_digits
  )
  
  message("hex_to_cnv: Preparing to write data to cnv.")
  gapctd:::write_to_cnv(data_list = cnv_dat, output_path = output_path) 
  
  return(cnv_dat)
  
}



#' Split a text string into bytes
#' @noRd

hex_line_to_raw <- function(line) {
  line_raw <- stringr::str_sub(
    line,
    seq(1, nchar(line) - 1, 2),
    seq(2, nchar(line), 2)
  )
  as.raw(paste0("0x", line_raw))
}

#' Convert bytes to unsigned integers
#' @noRd

hex_extract_raw_uint <- function(x, start, size, big_endian, scale = 1, offset = 0, ...) {
  x <- x[start:(start + size - 1)]
  
  # need to pad size 3 bytes to 4 for R to read
  if (size == 3 && big_endian) {
    x <- c(as.raw(0x00), x)
    size <- 4
  } else if (size == 3 && !big_endian) {
    x <- c(x, as.raw(0x00))
    size <- 4
  }
  
  con <- rawConnection(x)
  on.exit(close(con))
  # Approximate four byte unsigned integer
  value <- readBin(con, 
                   what = "integer", 
                   n = 1,
                   size = size, 
                   endian = if(big_endian) "big" else "little", 
                   signed = size >= 4
  )
  return(value / scale + offset)
}

#' Wrapper around hex_extract_raw_unit()
#' @noRd

hex_extract_raw_uint_tbl <- function(x, cols) {
  values <- purrr::pmap(cols, .f = gapctd:::hex_extract_raw_uint, x = x)
  names(values) <- cols$name
  
  return(tibble::as_tibble(values))
}



#' Convert SBE integer to ITS-90 temperature
#' @export

integer_to_temperature <- function(temperature_integer, 
                                   sig_figs = NULL, 
                                   a0, 
                                   a1, 
                                   a2, 
                                   a3, 
                                   offset = 0,
                                   par0 = 524288, 
                                   par1 = 1.6e7,
                                   par2 = 2.9e9,
                                   par3 = 1.024e8,
                                   par4 = 2.048e4,
                                   par5 = 2e5) {
  
  kelvin_zero_celcius <- 273.15
  
  # Convert temperature integer based on SBE
  t_v <- (temperature_integer - par0)/par1
  t_r <- (t_v * par2 + par3) / (par4 - t_v * par5)
  
  # Calibration equations
  t_x <- 1/(a0 + a1*log(t_r) + a2*log(t_r)^2+a3*log(t_r)^3) - kelvin_zero_celcius
  t_x <- t_x + offset
  
  if(is.numeric(sig_figs)) {
    t_x <- round(t_x, sig_figs)
  }
  
  return(t_x)
}


#' Convert SBE integer to pressure
#' @export

integer_to_pressure <- function(temperature_integer,
                                pressure_integer,
                                tvoltage_integer,
                                ptempa0,
                                ptempa1,
                                ptempa2,
                                ptca0,
                                ptca1,
                                ptca2,
                                ptcb0,
                                ptcb1,
                                ptcb2,
                                pa0,
                                pa1,
                                pa2,
                                par0 = 13107,
                                sig_figs = 3,
                                convert_to_dbar = TRUE) {
  
  # Convert integer voltage to actual units
  t_v <- tvoltage_integer/par0
  
  # Calibration equations
  t_x <- ptempa0 + ptempa1 * t_v + ptempa2 * t_v^2
  
  p_x <- pressure_integer - ptca0 - ptca1 * t_x - ptca2 * t_x^2
  
  p_n <- p_x * ptcb0 / (ptcb0 + ptcb1 * t_x + ptcb2 * t_x^2)
  
  # Pressure in pounds per square inch
  pressure <- pa0 + pa1 * p_n + pa2 * p_n ^2
  
  if(convert_to_dbar) {
    pressure <- (pressure - 14.7) * 0.689476
  }
  
  if(is.numeric(sig_figs)) {
    pressure <- round(pressure, sig_figs)
  }
  
  return(pressure)
  
}



#' Convert SBE integer to conductivity
#' @export

integer_to_conductivity <- function(conductivity_integer, temperature, pressure, condg, condh, condi, condj, cpcor, ctcor, par0 = 256, par1 = 1000, sig_figs = 6) {
  
  condf <- conductivity_integer / par0 / par1
  cond <- (condg + condh * condf^2 + condi * condf^3 + condj * condf^4) / (1 + ctcor * temperature + cpcor * pressure)
  
  if(is.numeric(sig_figs)) {
    cond <- round(cond, sig_figs)
  }
  
  return(cond)
}



#' Extract variable from xml
#' @export

get_calibration_parameter <- function(header, cal_par) {
  
  lines_par <- header[which(grepl(pattern = paste0("<", cal_par, ">"), header))][1]
  lines_par <- gsub(pattern = paste0(".*<", cal_par,">"), "", lines_par)
  lines_par <- gsub(pattern = paste0("</", cal_par, ">.*"), "", lines_par)
  par_value <- as.numeric(lines_par)
  return(par_value)
  
}



#' Writes outputs of hex_to_cnv to a .cnv file
#' 
#' Appends header data.
#' @noRd

write_to_cnv <- function(data_list, output_path) {
  
  dl <- data_list
  
  dl$data <- dl$data |>
    dplyr::select(names(dl$output_channels))
  
  out <- data_list$header
  
  out <- c(out, paste0("# nquan = ", length(dl[['output_channels']])))
  
  out <- c(out, paste0("# nvalues = ", nrow(dl$data)))
  
  if(!is.null(names(dl$output_channels))) {
    out <- c(out, paste0("# units = specified"))
  }
  
  out <- c(out, paste0("# name ", 1:length(dl$output_channels), " = ", dl$output_channels))
  
  out <- c(out, 
           paste0("# span ", 1:length(dl$output_channels), " = ", 
                  paste(
                    stringr::str_pad(apply(X = dl$data, MARGIN = 2, FUN = min), width = 10, side = "left"),
                    stringr::str_pad(apply(X = dl$data, MARGIN = 2, FUN = max), width = 10, side = "left"),
                    sep = ", ")))
  
  out <- c(out, 
           paste0("# interval = seconds: ", dl$sample_interval))
  
  
  time_index <- grep(pattern = "* cast", x = dl$header)
  
  out <- c(out, paste0("# start_time = ",   
                       substr(x = dl$header[time_index], start = 15, stop = 18),
                       substr(x = dl$header[time_index], start = 12, stop = 14),
                       substr(x = dl$header[time_index], start = 19, stop = 31),
                       " [Instrument's time stamp, header]"))
  out <- c(out, paste0("# bad_flag = -9.990e-29"))
  out <- c(out, paste0("# gapctd_date = ", format(Sys.time(), "%b %d %Y %T"), 
                       ", gapctd ", gsub(pattern = "'", replacement = "", x = packageVersion("gapctd"))))
  out <- c(out, paste0("# gapctd_in = ", dl$hex_path))
  out <- c(out, paste0("# file_type = ascii"))
  out <- c(out, "*END*")
  
  for(ii in 1:ncol(dl$data)) {
    col_index <- which(names(dl$output_sig_digits) %in% names(dl$data)[ii])
    
    dl$data[, col_index ] <- format(dl$data[, col_index ],
                                    nsmall = dl$output_sig_digits[col_index],
                                    width = 11,
                                    trim = FALSE,
                                    justify = "right")
  }
  
  dat_vec <- apply(X = dl$data[, 1:ncol(dl$data)] , MARGIN = 1 , FUN = paste , collapse = "")
  
  out <- c(out, dat_vec)
  
  file_conn <- file(output_path)
  writeLines(out, file_conn)
  close(file_conn)
  
}