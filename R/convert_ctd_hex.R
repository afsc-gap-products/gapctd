#' Convert hex files using SBE Data Processing software
#' 
#'  Converts .hex files to .cnv files using SBE Data Processing. Must have SBE Data Processing software installed for this function to work.
#'  
#'  @param ctd_directory_path Path to CTD directory
#'  @param xmlcon_path Path to xmlcon file
#'  @export

convert_ctd_hex <- function(ctd_directory_path, 
                            xmlcon_path, 
                            bat_file = NULL, 
                            datcnv_file = NULL) {
  
  if(is.null(bat_file)) {
    bat_file <- system.file("extdata/atsea/atsea_getdata.bat", package = "gapctd")    
  }
  
  if(is.null(datcnv_file)) {
    datcnv_file <- system.file("extdata/atsea/DatCnv.psa", package = "gapctd")
  }
  
  if(!dir.exists(paste0(getwd(), "/output"))) {
    dir.create(paste0(getwd(), "/output"))
  }
  
  if(!dir.exists(paste0(getwd(), "/data"))) {
    dir.create(paste0(getwd(), "/data"))
  }
  
  # Generate list of files
  hex_file_paths <- list.files(path = ctd_directory_path, 
                               pattern = ".hex",
                               full.names = TRUE)
  
  file.copy(from = hex_file_paths,
            to = gsub(pattern = ctd_directory_path, 
                      replacement = paste0(getwd(), "/data"),
                      x = hex_file_paths))
  
  # Run batch processing to generate raw .cnv files
  system(command = paste0("sbebatch \"", 
                          bat_file, "\" \"", 
                          getwd(), "\" \"", 
                          datcnv_file, "\" \"",
                          xmlcon_path, "\""))
}



#' Convert SBE19plus V2 hex files to cnv without SBE Data Processing
#'
#' This function decodes hexadecimal-formatted files that are generated by SeaTerm software then writes converted data to cnv files. Output files are similar to the output of SBE Data Processing software and can be read into R using oce::read.ctd().
#'
#' @param hex_path Path to a .hex file
#' @param output_path Path to the output file location for a .cnv file
#' @param xmlcon_file Optional. Path to config file. Must be provided if .hex file does not contain configuration file parameters.
#' @param sample_interval Sampling interval for scans; 0.25 for a typical SBE19plus V2 deployment.
#' @param output_channels Named vector of output channels and their names. Do not change from default unless additional channels of data are added.
#' @param output_sig_digits Significant digits after the decimal place for output channels. Do not change from default unless additional channels of data are added or sensor precision changes.
#' @export

hex_to_cnv <- function(hex_path,
                       output_path,
                       xmlcon_path = NULL,
                       sample_interval = 0.25,
                       output_channels = c("time_elapsed" = "timeS: Time, Elapsed [seconds]",
                                           "temperature" = "tv290C: Temperature [ITS-90, deg C]",
                                           "pressure" = "prdM: Pressure, Strain Gauge [db]",
                                           "conductivity" = "c0S/m: Conductivity [S/m]",
                                           "flag" = "flag:  0.000e+00"),
                       output_sig_digits = c("time_elapsed" = 3,
                                             "temperature" = 4,
                                             "pressure" = 3,
                                             "conductivity" = 6,
                                             "flag" = 1)) {
  
  stopifnot("hex_to_cnv: Error! output_channels and output_sig_digits must both be either a named character vector and named numeric vector, respectively -OR- both be NULL."  = (is.null(output_channels) & is.null(output_sig_digits)) | (is.character(output_channels) & is.numeric(output_sig_digits)))
  
  
  # Split-up hex file into header and hex data
  lines_hex <- readLines(hex_path)
  end_header <- grep(pattern = "*END*", x = lines_hex)
  last_line <- length(lines_hex)
  lines_header <- lines_hex[1:(end_header-1)]
  
  # xmlcon variable names do not match hex file names and must be substituted
  if(!is.null(xmlcon_path)) {
    xmlcon_header <- readLines(xmlcon_path)
    
    init_var <- c("<A0>", "<A1>", "<A2>", "<A3>", "</A0>", "</A1>", "</A2>", "</A3>", "CPcor", "CTcor")
    repl_var <- c("<TA0>", "<TA1>", "<TA2>", "<TA3>", "</TA0>", "</TA1>", "</TA2>", "</TA3>", "CPCOR", "CTCOR")
    
    for(hh in 1:length(init_var)) {
      xmlcon_header <- gsub(x = xmlcon_header, pattern = init_var[hh], replacement = repl_var[hh])
    }
    
    lines_header <- c(lines_header, paste("#", xmlcon_header))
    
  }
  
  lines_data <- lines_hex[(end_header+1):(last_line-1)]
  
  # Remove invalid lines at the end
  lines_raw <- purrr::map(lines_data, .f = gapctd:::hex_line_to_raw)
  
  # Index of hex values for different channels
  deployed_do <- any(grepl(pattern = "<OxygenSensor", x = lines_header))
  deployed_ph <- any(grepl(pattern = "<pH_Sensor", x = lines_header))
  
  
  hex_channels <- list(start = c(1, 4, 7, 10),
                       size = diff(c(1, 4, 7, 10, 12)),
                       big_endian = c(rep(TRUE, 4)),
                       name = c("temperature_int", "conductivity_int", "pressure_int", "tvoltage_int"))
  
  index_calibration_pars <- 1:25
  index_channels <- c(1:4,7)
  
  if(deployed_do) {
    hex_channels <- list(start = c(1, 4, 7, 10, 12),
                         size = diff(c(1, 4, 7, 10, 12, 14)),
                         big_endian = c(rep(TRUE, 5)),
                         name = c("temperature_int", "conductivity_int", "pressure_int", "tvoltage_int",
                                  "doxygen_int"))
    
    index_calibration_pars <- 1:38
    index_channels <- c(1:5,7)
  }
  
  if(deployed_do & deployed_ph) {
    hex_channels <- list(start = c(1, 4, 7, 10, 12, 14),
                         size = diff(c(1, 4, 7, 10, 12, 14, 16)),
                         big_endian = c(rep(TRUE, 6)),
                         name = c("temperature_int", "conductivity_int", "pressure_int", "tvoltage_int",
                                  "doxygen_int",
                                  "ph_int"))
    
    index_calibration_pars <- 1:40
    index_channels <- 1:7
  }
  
  # Setup output channels and significant digits if not provided as arguments.
  if(is.null(output_channels)) {
    
    output_channels <- c("time_elapsed" = "timeS: Time, Elapsed [seconds]",
                         "temperature" = "tv290C: Temperature [ITS-90, deg C]",
                         "pressure" = "prdM: Pressure, Strain Gauge [db]",
                         "conductivity" = "c0S/m: Conductivity [S/m]",
                         "oxygen" = "sbeox0ML/L: Oxygen, SBE 43 [ml/l]",
                         "ph" = "ph: pH",
                         "flag" = "flag:  0.000e+00")[index_channels]
    
    output_sig_digits <- c("time_elapsed" = 3,
                           "temperature" = 4,
                           "pressure" = 3,
                           "conductivity" = 6,
                           "oxygen" = 4,
                           "ph" = 3,
                           "flag" = 1)[index_channels]
    
    message(
      paste0("hex_to_cnv: ", 
                   length(index_channels), 
                   " data channels detected (", 
                   paste(names(output_channels), collapse = ", "), ")"
             )
      )
  }
  
  cols <- tibble::tibble(
    start = hex_channels$start,
    size = hex_channels$size,
    big_endian = hex_channels$big_endian,
    name = hex_channels$name
  )
  
  # Add list of bytes to a tbl
  lines_tbl <- tibble::tibble(
    lines_hex = lines_data,
    lines_raw = lines_raw,
    scan = seq_along(lines_raw),
    pos = purrr::map(lines_raw, seq_along)
  )
  
  # Split list based on hex index
  values_int <- lines_tbl |>
    dplyr::select(scan, lines_raw) |>
    tidyr::unnest(lines_raw) |>
    dplyr::group_by(scan) |>
    dplyr::summarise(gapctd:::hex_extract_raw_uint_tbl(lines_raw, cols = cols))
  
  
  # Retrieve calibration coefficients from header
  
  cal_par_names <- c("TA0", "TA1", "TA2", "TA3", "TOFFSET", "G", "H", "I", "J", "CPCOR", "CTCOR", "CSLOPE", "PA0", "PA1", "PA2", "PTEMPA0", "PTEMPA1", "PTEMPA2", "PTCA0", "PTCA1", "PTCA2", "PTCB0", "PTCB1", "PTCB2", "POFFSET", "A", "B", "C", "D0", "D1", "D2", "E", "Tau20", "H1", "H2", "H3", "offset", "Soc", "Slope", "Offset")[index_calibration_pars]
  
  cal_par_alias <- c("TA0", "TA1", "TA2", "TA3", "TOFFSET", "G", "H", "I", "J", "CPCOR", "CTCOR", "CSLOPE", "PA0", "PA1", "PA2", "PTEMPA0", "PTEMPA1", "PTEMPA2", "PTCA0", "PTCA1", "PTCA2", "PTCB0", "PTCB1", "PTCB2", "POFFSET", "DO_A", "DO_B", "DO_C", "DO_D0", "DO_D1", "DO_D2", "DO_E", "DO_Tau20", "DO_H1", "DO_H2", "DO_H3", "DO_Offset", "DO_Soc", "ph_Slope", "ph_Offset")[index_calibration_pars]
  
  start_block <- c(rep(NA, 25), rep("<OxygenSensor", 11), rep("Coefficients for Sea-Bird equation - SBE calibration in 2007 and later", 2), rep("<pH_Sensor", 2))[index_calibration_pars]
  end_block <- c(rep(NA, 25), rep("</OxygenSensor", 13), rep("</pH_Sensor", 2))[index_calibration_pars]
  
  cal_par_list <- list()
  
  for(ii in 1:length(cal_par_names)) {
    
    if(is.na(start_block[ii])) {
      cal_par_list[[cal_par_alias[ii]]] <- gapctd:::get_calibration_parameter(header = lines_header,
                                                                              cal_par = cal_par_names[ii])
    } else {
      cal_par_list[[cal_par_alias[ii]]] <- gapctd:::get_calibration_parameter(header = lines_header,
                                                                              cal_par = cal_par_names[ii],
                                                                              start_block = start_block[ii],
                                                                              end_block = end_block[ii])
    }
    
  }
  
  # Check that necessary calibration parameters were in the hex file header if no .xmlcon file was provided
  if(is.null(xmlcon_path)) {
    if(any(is.na(cal_par_list))) {
      stop(paste0("hex_to_cnv: Calibration parameters ", paste(names(cal_par_list)[is.na(cal_par_list)], collapse = ", "), "not found in ", hex_path))
    }
  }
  
  temperature  <- gapctd:::integer_to_temperature(
    temperature_integer = values_int$temperature_int,
    sig_figs = 4,
    a0 = cal_par_list[['TA0']],
    a1 = cal_par_list[['TA1']],
    a2 = cal_par_list[['TA2']],
    a3 = cal_par_list[['TA3']]
  )
  
  
  pressure <- gapctd:::integer_to_pressure(
    pressure_integer = values_int$pressure_int,
    temperature_integer = values_int$temperature_int,
    tvoltage_integer = values_int$tvoltage_int,
    ptempa0 = cal_par_list[['PTEMPA0']],
    ptempa1 = cal_par_list[['PTEMPA1']],
    ptempa2 = cal_par_list[['PTEMPA2']],
    ptca0 = cal_par_list[['PTCA0']],
    ptca1 = cal_par_list[['PTCA1']],
    ptca2 = cal_par_list[['PTCA2']],
    ptcb0 = cal_par_list[['PTCB0']],
    ptcb1 = cal_par_list[['PTCB1']],
    ptcb2 = cal_par_list[['PTCB2']],
    pa0 = cal_par_list[['PA0']],
    pa1 = cal_par_list[['PA1']],
    pa2 = cal_par_list[['PA2']],
    sig_figs = output_sig_digits['pressure'],
    convert_to_dbar = TRUE
  )
  
  conductivity <- gapctd:::integer_to_conductivity(
    conductivity_integer = values_int$conductivity_int,
    temperature = temperature,
    pressure = pressure,
    condg = cal_par_list[['G']],
    condh = cal_par_list[['H']],
    condi = cal_par_list[['I']],
    condj = cal_par_list[['J']],
    cpcor = cal_par_list[['CPCOR']],
    ctcor = cal_par_list[['CTCOR']],
    par0 = 256,
    par1 = 1000.0,
    sig_figs = output_sig_digits['conductivity']
  )
  
  # Process dissolved oxygen and pH if used
  dissolved_oxygen <- NA
  ph <- NA
  
  if(deployed_do) {
    salinity <- round(oce::swSCTp(conductivity = conductivity,
                            temperature = temperature,
                            pressure = pressure,
                            conductivityUnit = "S/m"), 4)
    
    dissolved_oxygen <- gapctd:::integer_to_dissolved_oxygen(do_integer = values_int$doxygen_int,
                                                             temperature = temperature,
                                                             pressure = pressure,
                                                             salinity = salinity,
                                                             a = cal_par_list[['DO_A']],
                                                             b = cal_par_list[['DO_B']],
                                                             c = cal_par_list[['DO_C']],
                                                             e = cal_par_list[['DO_E']],
                                                             soc = cal_par_list[['DO_Soc']],
                                                             Voffset = cal_par_list[['DO_Offset']],
                                                             d0 = cal_par_list[['DO_D0']],
                                                             d1 = cal_par_list[['DO_D1']],
                                                             d2 = cal_par_list[['DO_D2']],
                                                             tau20 = cal_par_list[['DO_Tau20']],
                                                             sample_interval = sample_interval,
                                                             sig_figs = output_sig_digits['oxygen'],
                                                             tau_correction = TRUE)
  }
  
  if(deployed_ph) {
    ph <- gapctd:::integer_to_ph(ph_integer = values_int$ph_int,
                                 ph_offset = cal_par_list[['ph_Offset']],
                                 ph_slope = cal_par_list[['ph_Slope']],
                                 temperature = temperature,
                                 sig_figs = output_sig_digits['ph'])
  }
  
  time_elapsed <- seq(0, (length(lines_data)-1)*sample_interval, sample_interval)
  flag <- rep(0, length(lines_data))
  
  cnv_dat <- list(
    data = data.frame(
      conductivity = conductivity,
      temperature = temperature,
      pressure = pressure,
      oxygen = dissolved_oxygen,
      ph = ph,
      time_elapsed = time_elapsed,
      flag = flag
    ),
    hex_path = hex_path,
    sample_interval = sample_interval,
    cal_par_list = cal_par_list,
    header = lines_header,
    output_channels = output_channels,
    output_sig_digits = output_sig_digits
  )
  
  if(!deployed_do) {
    cnv_dat$data <- dplyr::select(cnv_dat$data, -oxygen)
  }
  
  if(!deployed_ph) {
    cnv_dat$data <- dplyr::select(cnv_dat$data, -ph)
  }
  
  message("hex_to_cnv: Writing data to cnv.\n")
  gapctd:::write_to_cnv(data_list = cnv_dat, output_path = output_path)
  
  return(cnv_dat)
  
}



#' Split a text string into bytes
#' @noRd

hex_line_to_raw <- function(line) {
  line_raw <- stringr::str_sub(
    line,
    seq(1, nchar(line) - 1, 2),
    seq(2, nchar(line), 2)
  )
  as.raw(paste0("0x", line_raw))
}



#' Convert bytes to unsigned integers
#' @noRd

hex_extract_raw_uint <- function(x, start, size, big_endian, scale = 1, offset = 0, ...) {
  x <- x[start:(start + size - 1)]
  
  # need to pad size 3 bytes to 4 for R to read
  if (size == 3 && big_endian) {
    x <- c(as.raw(0x00), x)
    size <- 4
  } else if (size == 3 && !big_endian) {
    x <- c(x, as.raw(0x00))
    size <- 4
  }
  
  con <- rawConnection(x)
  on.exit(close(con))
  # Approximate four byte unsigned integer
  value <- readBin(con, 
                   what = "integer", 
                   n = 1,
                   size = size, 
                   endian = if(big_endian) "big" else "little", 
                   signed = size >= 4
  )
  return(value / scale + offset)
}

#' Wrapper around hex_extract_raw_unit()
#' @noRd

hex_extract_raw_uint_tbl <- function(x, cols) {
  values <- purrr::pmap(cols, .f = gapctd:::hex_extract_raw_uint, x = x)
  names(values) <- cols$name
  
  return(tibble::as_tibble(values))
}



#' Convert SBE integer to ITS-90 temperature
#' @export

integer_to_temperature <- function(temperature_integer, 
                                   sig_figs = NULL, 
                                   a0, 
                                   a1, 
                                   a2, 
                                   a3, 
                                   offset = 0,
                                   par0 = 524288, 
                                   par1 = 1.6e7,
                                   par2 = 2.9e9,
                                   par3 = 1.024e8,
                                   par4 = 2.048e4,
                                   par5 = 2e5) {
  
  kelvin_zero_celcius <- 273.15
  
  # Convert temperature integer based on SBE
  t_v <- (temperature_integer - par0)/par1
  t_r <- (t_v * par2 + par3) / (par4 - t_v * par5)
  
  # Calibration equations
  t_x <- 1/(a0 + a1*log(t_r) + a2*log(t_r)^2+a3*log(t_r)^3) - kelvin_zero_celcius
  t_x <- t_x + offset
  
  if(is.numeric(sig_figs)) {
    t_x <- round(t_x, sig_figs)
  }
  
  return(t_x)
}



#' Convert SBE integer to pressure
#' @export

integer_to_pressure <- function(temperature_integer,
                                pressure_integer,
                                tvoltage_integer,
                                ptempa0,
                                ptempa1,
                                ptempa2,
                                ptca0,
                                ptca1,
                                ptca2,
                                ptcb0,
                                ptcb1,
                                ptcb2,
                                pa0,
                                pa1,
                                pa2,
                                par0 = 13107,
                                sig_figs = 3,
                                convert_to_dbar = TRUE) {
  
  # Convert integer voltage to actual units
  t_v <- tvoltage_integer/par0
  
  # Calibration equations
  t_x <- ptempa0 + ptempa1 * t_v + ptempa2 * t_v^2
  
  p_x <- pressure_integer - ptca0 - ptca1 * t_x - ptca2 * t_x^2
  
  p_n <- p_x * ptcb0 / (ptcb0 + ptcb1 * t_x + ptcb2 * t_x^2)
  
  # Pressure in pounds per square inch
  pressure <- pa0 + pa1 * p_n + pa2 * p_n ^2
  
  if(convert_to_dbar) {
    pressure <- (pressure - 14.7) * 0.689476
  }
  
  if(is.numeric(sig_figs)) {
    pressure <- round(pressure, sig_figs)
  }
  
  return(pressure)
  
}



#' Convert SBE integer to conductivity
#' @export
integer_to_conductivity <- function(conductivity_integer, temperature, pressure, condg, condh, condi, condj, cpcor, ctcor, par0 = 256, par1 = 1000, sig_figs = 6) {
  
  condf <- conductivity_integer / par0 / par1
  cond <- (condg + condh * condf^2 + condi * condf^3 + condj * condf^4) / (1 + ctcor * temperature + cpcor * pressure)
  
  if(is.numeric(sig_figs)) {
    cond <- round(cond, sig_figs)
  }
  
  return(cond)
}



#' Convert SBE integer to pH
#' @export
integer_to_ph <- function(ph_integer, ph_offset, ph_slope, temperature, sig_figs = 3) {
  ph_voltage <- ph_integer/13107
  ph <- 7.0 + (ph_voltage - ph_offset)/(ph_slope * (temperature + 273.15) * 1.98416e-4)
  
  if(is.numeric(sig_figs)) {
    ph <- round(ph, sig_figs)
  }
  return(ph)
}



#' Extract variable from xml
#' @export

get_calibration_parameter <- function(header, cal_par, start_block = NULL, end_block = NULL) {
  
  # Subset header lines between start and end text
  if(!is.null(start_block) & !is.null(end_block)) {
    header <- header[which(grepl(pattern = start_block, x = header)):which(grepl(pattern = end_block, x = header))]
  }
  
  lines_par <- header[which(grepl(pattern = paste0("<", cal_par, ">"), header))][1]
  lines_par <- gsub(pattern = paste0(".*<", cal_par,">"), "", lines_par)
  lines_par <- gsub(pattern = paste0("</", cal_par, ">.*"), "", lines_par)
  par_value <- as.numeric(lines_par)
  return(par_value)
  
}



#' Writes outputs of hex_to_cnv to a .cnv file
#' 
#' Appends header data.
#' @noRd

write_to_cnv <- function(data_list, output_path) {
  
  dl <- data_list
  
  dl$data <- dl$data |>
    dplyr::select(names(dl$output_channels))
  
  out <- data_list$header
  
  out <- c(out, paste0("# nquan = ", length(dl[['output_channels']])))
  
  out <- c(out, paste0("# nvalues = ", nrow(dl$data)))
  
  if(!is.null(names(dl$output_channels))) {
    out <- c(out, paste0("# units = specified"))
  }
  
  out <- c(out, paste0("# name ", 1:length(dl$output_channels), " = ", dl$output_channels))
  
  out <- c(out, 
           paste0("# span ", 1:length(dl$output_channels), " = ", 
                  paste(
                    stringr::str_pad(apply(X = dl$data, MARGIN = 2, FUN = min), width = 10, side = "left"),
                    stringr::str_pad(apply(X = dl$data, MARGIN = 2, FUN = max), width = 10, side = "left"),
                    sep = ", ")))
  
  out <- c(out, 
           paste0("# interval = seconds: ", dl$sample_interval))
  
  
  time_index <- grep(pattern = "* cast", x = dl$header)
  
  out <- c(out, paste0("# start_time = ",   
                       substr(x = dl$header[time_index], start = 15, stop = 18),
                       substr(x = dl$header[time_index], start = 12, stop = 14),
                       substr(x = dl$header[time_index], start = 19, stop = 31),
                       " [Instrument's time stamp, header]"))
  out <- c(out, paste0("# bad_flag = -9.990e-29"))
  out <- c(out, paste0("# gapctd_date = ", format(Sys.time(), "%b %d %Y %T"), 
                       ", gapctd ", gsub(pattern = "'", replacement = "", x = packageVersion("gapctd"))))
  out <- c(out, paste0("# gapctd_in = ", dl$hex_path))
  out <- c(out, paste0("# file_type = ascii"))
  out <- c(out, "*END*")
  
  for(ii in 1:ncol(dl$data)) {
    col_index <- which(names(dl$output_sig_digits) %in% names(dl$data)[ii])
    
    dl$data[, col_index ] <- format(dl$data[, col_index ],
                                    nsmall = dl$output_sig_digits[col_index],
                                    width = 11,
                                    trim = FALSE,
                                    justify = "right")
  }
  
  dat_vec <- apply(X = dl$data[, 1:ncol(dl$data)] , MARGIN = 1 , FUN = paste , collapse = "")
  
  out <- c(out, dat_vec)
  
  file_conn <- file(output_path)
  writeLines(out, file_conn)
  close(file_conn)
  
}



#' Calculate oxygen saturation (ml/l)
#' 
#' Calculate oxygen saturation as a function of temperature and salinity based on oxygen solubility from Garcia and Gordon (1992).
#' 
#' @param temperature Temperature (degrees Celsius).
#' @param salinity Salinity (PSU, PSS-78).
#' @export
#' @references Garcia, H.E., Gordon, L.I., 1992. Oxygen solubility in seawater: Better fitting equations. Limnol. Oceanogr. 37, 1307–1312. https://doi.org/10.4319/lo.1992.37.6.1307

oxygen_saturation <- function(temperature, salinity) {
  
  # Constants
  A0 <- 2.00856
  A1 <- 3.22400
  A2 <- 3.99063
  A3 <- 4.80299
  A4 <- 9.78188e-01
  A5 <- 1.71069
  B0 <- -6.24097e-03
  B1 <- -6.93498e-03
  B2 <- -6.90358e-03
  B3 <- -4.29155e-03
  C0 <- -3.11680e-07
  
  Ts <- log((298.15 - temperature) / (273.15 + temperature))
  
  A <- ((((A5 * Ts + A4) * Ts + A3) * Ts + A2) * Ts + A1) * Ts + A0
  
  B <- ((B3 * Ts + B2) * Ts + B1) * Ts + B0
  
  O2 <- exp(A + salinity*(B + salinity*C0))
  
  return(O2)
  
}



#' Calculate oxygen saturation (percent) from dissolved oxygen (ml/l)
#' 
#' Dissolved oxygen divided by oxygen saturation calculated following Garcia and Gordon (1992)
#' 
#' @param oxygen Dissolved oxygen in ml/l
#' @param temperature Temperature (IPTS-68, degrees Celsius).
#' @param salinity Salinity (PSU, PSS-78).
#' @export
#' @references Garcia, H.E., Gordon, L.I., 1992. Oxygen solubility in seawater: Better fitting equations. Limnol. Oceanogr. 37, 1307–1312. https://doi.org/10.4319/lo.1992.37.6.1307

convert_do_to_o2sat <- function(oxygen, temperature, salinity) {
  
  oxsol <- gapctd:::oxygen_saturation(temperature = temperature,
                                      salinity = salinity)
  
  return(oxygen/oxsol)
}



#' Convert SBE integer to dissolved oxygen (ml/l)
#' 
#' @param do_integer Integer value of dissolved oxygen decoded from hex
#' @param tau_correction Should the tau correction (Edwards et al., 2009) be used to account for time-dynamic errors in oxygen?
#' @param temperature Temperature (IPTS-68, degrees Celsius).
#' @param salinity Salinity (PSU, PSS-78).
#' @param pressure Pressure (dbar).
#' @param Voffset Voltage channel offset.
#' @param a Calibration parameter A.
#' @param b Calibration parameter b.
#' @param c Calibration equation parameter C.
#' @param e Calibration equation parameter E.
#' @param soc Calibration equation parameter Soc.
#' @param d0 Tau correction calibration parameter D0.
#' @param d1 Tau correction calibration parameter D1.
#' @param d2 Tau correction calibration parameter D2.
#' @param d0 Tau correction calibration parameter Tau20.
#' @param sample_interval Sample interval in seconds (default = 0.25).
#' @export
#' @references Edwards, B., Murphy, D., Janzen, C., Larson, A.N., 2010. Calibration, response, and hysteresis in deep-sea dissolved oxygen measurements. J. Atmos. Ocean. Technol. 27, 920–931. https://doi.org/10.1175/2009JTECHO693.1
 
integer_to_dissolved_oxygen <- function(do_integer,
                                        temperature,
                                        pressure,
                                        salinity,
                                        a,
                                        b,
                                        c,
                                        e,
                                        soc,
                                        Voffset,
                                        tau20 = NULL,
                                        d0 = NULL,
                                        d1 = NULL,
                                        d2 = NULL,
                                        sample_interval = 0.25,
                                        tau_correction = TRUE
) {
  
  do_voltage <- do_integer/13107
  
  oxsol <- gapctd:::oxygen_saturation(temperature = temperature,
                                      salinity = salinity)
  
  tau <- 0
  dVdt <- 0
  
  if(tau_correction) {
    tau <- tau20 * d0 * exp(d1 * pressure + d2 * (temperature-20))
    dVdt <- c(0, diff(do_voltage)/sample_interval)
  }
  
  temperature_K <- temperature + 273.15
  
  oxygen_mll <- soc * (do_voltage + Voffset + tau * dVdt) * (1 + a * temperature + b * temperature^2 + c * temperature^3) * oxsol * exp(e*pressure/temperature_K)
  
  return(oxygen_mll)
}