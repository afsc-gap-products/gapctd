#' Detect R vector class and return equivalent netCDF class
#' 
#' Supports numeric, integer, and character classes.
#' 
#' @param vec A vector of any type.
#' @export

vec_to_nc_class <- function(vec, pkg = "RNetCDF") {
  vec_class <- class(vec)
  if(pkg == "RNetCDF") {
    if(vec_class == "numeric") {
      if(suppressWarnings(all(vec %% 1 == 0))) {
        prec <- "NC_INT"
      } else {
        prec <- "NC_FLOAT"
      }
    } else if(vec_class == "integer") {
      prec <- "NC_INT"
    } else if(vec_class == "character") {
      prec <- "NC_STRING"
    } else {
      stop(paste0("Class ", vec_class, " not supported in netCDF"))
    }
  } else if(pkg == "ncdf4") {
    if(vec_class == "numeric") {
      if(suppressWarnings(all(vec %% 1 == 0))) {
        prec <- "integer"
      } else {
        prec <- "float"
      }
    } else if(vec_class == "integer") {
      prec <- "integer"
    } else if(vec_class == "character") {
      prec <- "char"
    } else {
      stop(paste0("Class ", vec_class, " not supported in netCDF"))
    }
  }
  return(prec)
}

#' Retrieve haul event times from RACEBASE
#' 
#' Retrieves on bottom, haul back, off bottom, and marked event times from RACE_DATA.
#' 
#' @param channel An RODBC connection to Oracle.
#' @param haul_metadata_path Character vector. Path to haul data .csv generated by create_NMEA().
#' @param append_haul_metadata Logical. Should the file named in haul_metadata_path be appended (overwritten) to include haul events?
#' @export

get_haul_events <- function(haul_metadata_path = list.files(paste0(getwd(), "/metadata/"), full.names = TRUE),
                            append_haul_metadata = TRUE,
                            channel) {
  
  if(length(haul_metadata_path) != 1) {
    stop(paste("get_haul_events(): Argument haul_meta_data path must only be file but has length ", length(haul_metadata_path)))
  }
  
  haul_metadata <- read.csv(file = haul_metadata_path, stringsAsFactors = FALSE)
  
  unique_vessel_cruise <- haul_metadata |>
    dplyr::select(VESSEL, CRUISE) |>
    unique()
  
  events_df <- data.frame()
  for(i in 1:nrow(unique_vessel_cruise)) {
    
    events_df <- 
      RODBC::sqlQuery(channel = channel, 
                      query = paste0("select a.vessel_id vessel, 
                        a.cruise cruise, 
                         b.haul haul,
                         c.edit_date_time date_time, 
                         c.event_type_id time_flag
                         from 
                         race_data.cruises a,
                         race_data.hauls b,
                         race_data.events c,
                         race_data.datum_codes d
                         where 
                         a.cruise = ", unique_vessel_cruise$CRUISE[i],
                                     " and a.vessel_id = ", unique_vessel_cruise$VESSEL[i],
                                     " and b.cruise_id = a.cruise_id
                          and c.haul_id = b.haul_id
                          and c.event_type_id in (3,5,6,7)
                          and c.datum_code = d.datum_code
                          and d.use_in_analysis = 'Y'")) |>
      dplyr::inner_join(data.frame(TIME_FLAG = c(3,5,6,7),
                                   EVENT_NAME = c("ON_BOTTOM", "MARKED_EVENT", "HAULBACK", "OFF_BOTTOM"))) |>
      tidyr::pivot_wider(id_cols = c("VESSEL", "CRUISE", "HAUL"),
                         names_from = c("EVENT_NAME"),
                         values_from = "DATE_TIME") |>
      dplyr::bind_rows(events_df)
  }
  
  events_df <- haul_metadata |> 
    dplyr::inner_join(events_df)
  
  if(nrow(haul_metadata) != nrow(events_df)) {
    warning(print("get_haul_events(): Length of haul metadata input (", nrow(haul_metadata), ") differs from length of output with haul events (", nrow(events_df) , ")"))
  }
  
  if(append_haul_metadata) {
    write.csv(x = events_df, 
              file = haul_metadata_path, 
              row.names = FALSE)
  }
  
  return(events_df)
}

#' Create a database connection using RODBC
#'
#' A function that accepts a data source name, username, and password to establish returns an Oracle DataBase Connection (ODBC) as an RODBC class in R.
#'
#' @param schema Data source name (DSN) as a character vector.
#' @return An RODBC class ODBC connection.
#' @export

get_connected <- function(schema = NA){
  (echo = FALSE)
  if(is.na(schema)) {
    schema <- getPass::getPass(msg = "Enter ORACLE schema: ")
  }
  username <- getPass::getPass(msg = "Enter your ORACLE Username: ")
  password <- getPass::getPass(msg = "Enter your ORACLE Password: ")
  channel  <- RODBC::odbcConnect(dsn = paste(schema),
                                 uid = paste(username),
                                 pwd = paste(password),
                                 believeNRows = FALSE)
}


#' Estimate time adjustment for Align CTD
#' 
#' Find the time adjustment that maximizes correlations of first time differences between variables (i.e., dx/dt), similar to Ullman and Herbert (2014). 
#' 
#' @param var1 Numeric vector of measurements from the first sensors (e.g., conductivity)
#' @param var2 Numeric vector of measurements from the sensor for which measurements will be time-adjuste (e.g., temperature)
#' @param time1 Scan time in seconds as a numeric vector for the first sensor.
#' @param time2 Scan time in seconds as a numeric vector for the second sensor.
#' @param time2_adjustments Adjustments to try, in seconds, as a numeric vector.
#' @param cor_method Correlation method to use to evaluate time2_adjustment as a character vector. See documentation for cor().
#' @param interp_fn Character vector indicating which interpolation function to use ("approx" or "oce::oce.approx") to estimate time-shifted values at shifted scan times.
#' @param interp_method Interpolation method to apply to estimate time-shifted measurements. See documentation for approx() and oce::oce.approx()
#' @param return_adj Logical indicating whether to return only the time2_adjustments value with the best correlation (TRUE) or a list containing additional results (see Details below)
#' @details  This function time-shifts measurements from one sensor (e.g. temperature) relative to measurements from another sensor (e.g. conductivity) for all user-provided time2_adjustment values. It then estimates a correlations between time-shifted sensor measurements and returns either the best time2_adustment estimate or a list containing the best time2_adjustment, highest correlation, and data.frame containing results of all time2_adustment comparisons. Time-shifted values between measurements can be interpolated using "rr" or "unesco" from oce::oce.approx or the "linear" method in approx. Correlation methods are any valid methods in cor().
#' @references Ullman, D.S., Hebert, D., 2014. Processing of underway CTD data. J. Atmos. Ocean. Technol. 31, 984â€“998. https://doi.org/10.1175/JTECH-D-13-00200.1
#' @export

estimate_alignment <- function(var1, var2, time1, time2, time2_adjustments = seq(-1.5,1.5,0.01), cor_method = "spearman", interp_method = "linear", interp_fn = "approx", only_return_adj = TRUE) {
  
  series_1 <- data.frame(t = time1,
                         x1 = var1)
  
  s2_series <- data.frame(t = time2,
                          x1 = var2)
  
  corr_vec <- numeric(length = length(time2_adjustments))
  
  for(jj in 1:length(time2_adjustments)) {
    
    series_2 <- s2_series
    series_2$t <- series_2$t + time2_adjustments[jj]
    
    loc_pred <- data.frame(locs = unique(c(series_1$t, series_2$t)))
    
    loc_pred$s1 <- switch(interp_fn,
                          `oce.approx` = {oce::oce.approx(x = series_1$t, 
                                                          y = series_1$x1, 
                                                          xout = loc_pred$locs, 
                                                          method = interp_method)},
                          `approx` = { approx(x = series_1$t, 
                                              y = series_1$x1, 
                                              xout = loc_pred$locs, 
                                              method = interp_method)$y})
    
    loc_pred$s2 <- switch(interp_fn,
                          `oce.approx` = {oce::oce.approx(x = series_2$t, 
                                                          y = series_2$x1, 
                                                          xout = loc_pred$locs, 
                                                          method = interp_method)},
                          `approx` = {approx(x = series_2$t, 
                                             y = series_2$x1, 
                                             xout = loc_pred$locs, 
                                             method = interp_method)$y})
    
    obj <- 1-cor(diff(loc_pred$s1), 
                 diff(loc_pred$s2), 
                 use = "complete.obs",
                 method = cor_method)
    corr_vec[jj] <- obj
    
  }
  
  if(only_return_adj) {
    return(-1*time2_adjustments[which.min(corr_vec)])
  } else{
    return(list(time2_adj = -1*time2_adjustments[which.min(corr_vec)],
                adj_cor = min(corr_vec),
                adj_est = data.frame(time2_adjustment = time2_adjustments,
                                     correlation = corr_vec,
                                     cor_method = cor_method)))
  }
}