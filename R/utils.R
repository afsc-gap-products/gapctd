#' Retrieve haul event times from RACEBASE
#' 
#' Retrieves on bottom, haul back, off bottom, and marked event times from RACE_DATA.
#' 
#' @param channel An RODBC connection to Oracle.
#' @param haul_metadata_path Character vector. Path to haul data .csv generated by create_NMEA().
#' @param append_haul_metadata Logical. Should the file named in haul_metadata_path be appended (overwritten) to include haul events?
#' @export

get_haul_events <- function(haul_metadata_path = list.files(paste0(getwd(), "/metadata/"), full.names = TRUE),
                            append_haul_metadata = TRUE,
                            channel) {
  
  if(length(haul_metadata_path) != 1) {
    stop(paste("get_haul_events(): Argument haul_meta_data path must only be file but has length ", length(haul_metadata_path)))
  }
  
  haul_metadata <- read.csv(file = haul_metadata_path, stringsAsFactors = FALSE)
  
  unique_vessel_cruise <- haul_metadata |>
    dplyr::select(VESSEL, CRUISE) |>
    unique()
  
  events_df <- data.frame()
  for(i in 1:nrow(unique_vessel_cruise)) {
    
    events_df <- 
      RODBC::sqlQuery(channel = channel, 
                      query = paste0("select a.vessel_id vessel, 
                        a.cruise cruise, 
                         b.haul haul,
                         c.edit_date_time date_time, 
                         c.event_type_id time_flag
                         from 
                         race_data.cruises a,
                         race_data.hauls b,
                         race_data.events c,
                         race_data.datum_codes d
                         where 
                         a.cruise = ", unique_vessel_cruise$CRUISE[i],
                                     " and a.vessel_id = ", unique_vessel_cruise$VESSEL[i],
                                     " and b.cruise_id = a.cruise_id
                          and c.haul_id = b.haul_id
                          and c.event_type_id in (3,6,7)
                          and c.datum_code = d.datum_code
                          and d.use_in_analysis = 'Y'")) |>
      dplyr::inner_join(data.frame(TIME_FLAG = c(3,6,7),
                                   EVENT_NAME = c("ON_BOTTOM", "HAULBACK", "OFF_BOTTOM"))) |>
      tidyr::pivot_wider(id_cols = c("VESSEL", "CRUISE", "HAUL"),
                         names_from = c("EVENT_NAME"),
                         values_from = "DATE_TIME") |>
      dplyr::bind_rows(events_df)
  }
  
  events_df <- haul_metadata |> 
    dplyr::inner_join(events_df)
  
  if(nrow(haul_metadata) != nrow(events_df)) {
    warning(print("get_haul_events(): Length of haul metadata input (", nrow(haul_metadata), ") differs from length of output with haul events (", nrow(events_df) , ")"))
  }
  
  if(append_haul_metadata) {
    write.csv(x = events_df, 
              file = haul_metadata_path, 
              row.names = FALSE)
  }
  
  return(events_df)
}

#' Create a database connection using RODBC
#'
#' A function that accepts a data source name, username, and password to establish returns an Oracle DataBase Connection (ODBC) as an RODBC class in R.
#'
#' @param schema Data source name (DSN) as a character vector.
#' @return An RODBC class ODBC connection.
#' @export

get_connected <- function(schema = NA){
  (echo = FALSE)
  if(is.na(schema)) {
    schema <- getPass::getPass(msg = "Enter ORACLE schema: ")
  }
  username <- getPass::getPass(msg = "Enter your ORACLE Username: ")
  password <- getPass::getPass(msg = "Enter your ORACLE Password: ")
  channel  <- RODBC::odbcConnect(dsn = paste(schema),
                                 uid = paste(username),
                                 pwd = paste(password),
                                 believeNRows = FALSE)
}

#' Convert decimal degree latitude to NMEA format
#' 
#' @param x Numeric decimal degrees
#' @noRd

ddlat_to_nmea <- function(x) {
  paste0(format(floor(abs(x)), 2), " ", 
         format(abs(x)%%1*60, nsmall = 3), " ",
         c("S", "N")[sign(x) == c(-1, 1)])
}

#' Convert decimal degree longitude to NMEA format
#' 
#' @param x Numeric decimal degrees
#' @noRd

ddlon_to_nmea <- function(x) {
  paste0(format(floor(abs(x)), 2), " ", 
         format(abs(x)%%1*60, nsmall = 3), " ",
         c("W", "E")[sign(x) == c(-1, 1)])
}

#' Package final files and metadata in a zip file
#' 
#' @param region Survey region
#' @param vessel Survey vessel
#' @param year Survey year
#' @export

make_ctd_zip <- function(region, vessel, year) {
  
  xmlcon_text <- readLines(paste0("./psa_xmlcon/", list.files("./psa_xmlcon/", pattern = ".xmlcon")))
  
  serial_number <- xmlcon_text[which(grepl(pattern = "<SerialNumber>", xmlcon_text))][1]
  serial_number <- gsub(pattern = ".*<SerialNumber>", "", serial_number)
  serial_number <- gsub(pattern = "</SerialNumber>.*", "", serial_number)
  
  zip_name <- paste0("CTD_", year, "_", region, "_", vessel, "_", serial_number, ".zip")
  
  message(paste0("Writing CTD data to ", zip_name))
  utils::zip(zipfile = zip_name, files = "./metadata/")
  utils::zip(zipfile = zip_name, files = "./final_cnv/")
  utils::zip(zipfile = zip_name, files = "./data/")
  utils::zip(zipfile = zip_name, files = paste0("./output/", list.files("./output/", pattern = ".rds")))
  utils::zip(zipfile = zip_name, files = "./output/accepted_profiles/")
  utils::zip(zipfile = zip_name, files = paste0("./psa_xmlcon/", list.files("./psa_xmlcon/", pattern = ".xmlcon")))
  
}