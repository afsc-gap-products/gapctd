#' Detect R vector class and return equivalent netCDF class
#' 
#' Supports numeric, integer, and character classes.
#' 
#' @param vec A vector of any type.
#' @export

vec_to_nc_class <- function(vec, pkg = "RNetCDF") {
  vec_class <- class(vec)
  if(pkg == "RNetCDF") {
    if(vec_class == "numeric") {
      if(suppressWarnings(all(vec %% 1 == 0))) {
        prec <- "NC_INT"
      } else {
        prec <- "NC_FLOAT"
      }
    } else if(vec_class == "integer") {
      prec <- "NC_INT"
    } else if(vec_class == "character") {
      prec <- "NC_STRING"
    } else {
      stop(paste0("Class ", vec_class, " not supported in netCDF"))
    }
  } else if(pkg == "ncdf4") {
    if(vec_class == "numeric") {
      if(suppressWarnings(all(vec %% 1 == 0))) {
        prec <- "integer"
      } else {
        prec <- "float"
      }
    } else if(vec_class == "integer") {
      prec <- "integer"
    } else if(vec_class == "character") {
      prec <- "char"
    } else {
      stop(paste0("Class ", vec_class, " not supported in netCDF"))
    }
  }
  return(prec)
}

#' Retrieve haul event times from RACEBASE
#' 
#' Retrieves on bottom, haul back, off bottom, and marked event times from RACE_DATA.
#' 
#' @param channel An RODBC connection to Oracle.
#' @param haul_metadata_path Character vector. Path to haul data .csv generated by create_NMEA().
#' @param append_haul_metadata Logical. Should the file named in haul_metadata_path be appended (overwritten) to include haul events?
#' @export

get_haul_events <- function(haul_metadata_path = list.files(paste0(getwd(), "/metadata/"), full.names = TRUE),
                            append_haul_metadata = TRUE,
                            channel) {
  
  if(length(haul_metadata_path) != 1) {
    stop(paste("get_haul_events(): Argument haul_meta_data path must only be file but has length ", length(haul_metadata_path)))
  }
  
  haul_metadata <- read.csv(file = haul_metadata_path, stringsAsFactors = FALSE)
  
  unique_vessel_cruise <- haul_metadata |>
    dplyr::select(VESSEL, CRUISE) |>
    unique()
  
  events_df <- data.frame()
  for(i in 1:nrow(unique_vessel_cruise)) {
    
    events_df <- 
      RODBC::sqlQuery(channel = channel, 
                      query = paste0("select a.vessel_id vessel, 
                        a.cruise cruise, 
                         b.haul haul,
                         c.edit_date_time date_time, 
                         c.event_type_id time_flag
                         from 
                         race_data.cruises a,
                         race_data.hauls b,
                         race_data.events c,
                         race_data.datum_codes d
                         where 
                         a.cruise = ", unique_vessel_cruise$CRUISE[i],
                                     " and a.vessel_id = ", unique_vessel_cruise$VESSEL[i],
                                     " and b.cruise_id = a.cruise_id
                          and c.haul_id = b.haul_id
                          and c.event_type_id in (3,5,6,7)
                          and c.datum_code = d.datum_code
                          and d.use_in_analysis = 'Y'")) |>
      dplyr::inner_join(data.frame(TIME_FLAG = c(3,5,6,7),
                                   EVENT_NAME = c("ON_BOTTOM", "MARKED_EVENT", "HAULBACK", "OFF_BOTTOM"))) |>
      tidyr::pivot_wider(id_cols = c("VESSEL", "CRUISE", "HAUL"),
                         names_from = c("EVENT_NAME"),
                         values_from = "DATE_TIME") |>
      dplyr::bind_rows(events_df)
  }
  
  events_df <- haul_metadata |> 
    dplyr::inner_join(events_df)
  
  if(nrow(haul_metadata) != nrow(events_df)) {
    warning(print("get_haul_events(): Length of haul metadata input (", nrow(haul_metadata), ") differs from length of output with haul events (", nrow(events_df) , ")"))
  }
  
  if(append_haul_metadata) {
    write.csv(x = events_df, 
              file = haul_metadata_path, 
              row.names = FALSE)
  }
  
  return(events_df)
}

#' Create a database connection using RODBC
#'
#' A function that accepts a data source name, username, and password to establish returns an Oracle DataBase Connection (ODBC) as an RODBC class in R.
#'
#' @param schema Data source name (DSN) as a character vector.
#' @return An RODBC class ODBC connection.
#' @export

get_connected <- function(schema = NA){
  (echo = FALSE)
  if(is.na(schema)) {
    schema <- getPass::getPass(msg = "Enter ORACLE schema: ")
  }
  username <- getPass::getPass(msg = "Enter your ORACLE Username: ")
  password <- getPass::getPass(msg = "Enter your ORACLE Password: ")
  channel  <- RODBC::odbcConnect(dsn = paste(schema),
                                 uid = paste(username),
                                 pwd = paste(password),
                                 believeNRows = FALSE)
}