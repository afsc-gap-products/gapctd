#' Manually flagging points for removal and interpolate flagged values.
#' 
#' Manually flag values from a cast for removal and interpolate removed/missing values.
#' 
#' @param file_paths Character vector of paths to cnv files to process.
#' @param haul_metadata_path Character vector. ONLY USED IF file_paths = NULL. Path to haul data .csv generated by get_bottom_data().
#' @param cast_dir_filepath Cast directory file path. ONLY USED IF file_paths = NULL.
#' @param var Variable to search for point removal
#' @param z_var Character vector indicating which variable to use for the vertical dimension ("depth" or "pressure")
#' @param flag_filename Character vector indicating where to store information about the flagged data for each cast.
#' @param start_index Numeric vector indicating which haul to start with.
#' @param var_range_min Numeric vector (1L) indicating the minimum x-axis range to use for plotting the selected variable.
#' @param interpolation_method Method to use for interpolation. Options are "unesco" = oce::oceApprox(method = "unesco") "rr" = oce::oceApprox(method = "rr") in , "linear" = approx(method = "linear"), or "none" = no interpolation.
#' @export

manual_flag_interpolate <- function(file_paths = NULL,
                                    haul_metadata_path = list.files(here::here("metadata"), full.names = TRUE),
                                    cast_dir_filepath = here::here("final_cnv"),
                                    var = "salinity",
                                    z_var = "pressure",
                                    flag_filename = here::here("output", "manual_flag_points.csv"),
                                    interpolation_method = "unesco",
                                    var_range_min = 0.1) {
  
  if(!dir.exists(here::here("output", "manual_flag"))) {
    dir.create(here::here("output", "manual_flag"))
  }
  
  if(is.null(file_paths)) {
    haul_metadata <- read.csv(file = haul_metadata_path, 
                              stringsAsFactors = FALSE)
    n_vals <- nrow(haul_metadata)
  } else{
    n_vals <- length(file_paths)
  }
  
  for(kk in 1:nrow(haul_metadata)) {
      
      binned_df <- NULL
      
      if(is.null(file_paths)) {
        # Working from the directory
        deploy_id <- sub("\\_raw.*", "", haul_metadata$cnv_file_name[kk])
        f_list <- list.files(cast_dir_filepath, 
                             pattern = deploy_id, 
                             full.names = TRUE)
        
        if(file.exists(here::here("output", "manual_flag", paste0(sub("\\_raw.*", "", deploy_id), "_flag_interp.csv")))) {
          next
        }
        
        if(file.exists(here::here("output", "accepted_profiles", paste0(sub("\\_raw.*", "", deploy_id), "_accepted.csv")))) {
          next
        }
        
        # Ignore bad casts
        downcast <- try(oce::read.ctd(file = f_list[grepl(pattern = paste0("_downcast"), x = f_list)]), silent = TRUE)
        upcast <- try(oce::read.ctd(file = f_list[grepl(pattern = paste0("_upcast"), x = f_list)]), silent = TRUE)
        
        down_pres <- try(diff(range(downcast@data$pressure)) < 9, silent = TRUE)
        up_pres <- try(diff(range(upcast@data$pressure)) < 9, silent = TRUE)
        
        if(class(down_pres) == "try-error") {down_pres <- TRUE}    
        if(class(up_pres) == "try-error") {up_pres <- TRUE}
        if(down_pres) {downcast <- "try-error"}
        if(up_pres) { upcast <- "try-error"}
      } else {
        # Working with a list of files
        deploy_id <- file_paths[kk]
        
        downcast <- try(oce::read.ctd(file = file_paths[kk]), silent = TRUE)
        down_pres <- try(diff(range(downcast@data$pressure)) < 9, silent = TRUE)
        if(class(down_pres) == "try-error") {down_pres <- TRUE}
        
        up_pres <- TRUE
      }
      
      if(!file.exists(here::here("output", "manual_flag", paste0(sub("\\_raw.*", "", deploy_id), "_flag_interp.csv")))) {
      
      if(down_pres+up_pres <= 1) {
        
        print(paste0("Flagging data from ", deploy_id, " (index ", kk, " out of ", nrow(haul_metadata), ")"))
        
        for(mm in 1:length(var)) {
          
          if(!down_pres) {
            down_df <- aggregate(x = data.frame(var_downcast = eval(parse(text = paste0("downcast@data$", var[mm]))),
                                                z_downcast = eval(parse(text = paste0("downcast@data$", z_var)))), 
                                 by = list(z_bin = round(eval(parse(text = paste0("downcast@data$", z_var))))), 
                                 FUN = mean)
          }
          
          if(!up_pres) {
            up_df <- aggregate(x = data.frame(var_upcast = eval(parse(text = paste0("upcast@data$", var[mm]))),
                                              z_upcast = eval(parse(text = paste0("upcast@data$", z_var)))), 
                               by = list(z_bin = round(eval(parse(text = paste0("upcast@data$", z_var))))), 
                               FUN = mean)
          }
          
          if(!down_pres & !up_pres) {
            binned_df <- dplyr::full_join(down_df, 
                                          up_df, 
                                          by = "z_bin")
          } else if(!down_pres & up_pres) {
            binned_df <- down_df
          } else if(down_pres & !up_pres) {
            binned_df <- up_df
          }
          
          names(binned_df)[which(names(binned_df) == "var_upcast")] <- paste0(var[mm], "_upcast")
          names(binned_df)[which(names(binned_df) == "var_downcast")] <- paste0(var[mm], "_downcast")
          
          binned_df <- binned_df[, -which(names(binned_df) %in% c("z_downcast", "z_upcast"))]
          
          dir_vec <- c("downcast", "upcast")[c(!(class(downcast) == "try-error"), !(class(upcast) == "try-error"))]
          loop_flag <- 0
          
          if(length(dir_vec) >= 1) {
            
            for(ii in 1:length(dir_vec)) {
              
              print(paste0("Start flagging ", sub("\\_raw.*", "", haul_metadata$cnv_file_name[kk], " ", dir_vec[ii])))
              cast_index <- numeric(length = 0L)
              
              col_index <- which(names(binned_df) == paste0(var[mm], "_", dir_vec[ii]))
              
              # Skip if column doesn't exist
              if(length(col_index) < 1) {
                next
              }
              
              # Z bins to ignore because they are deeper than the maximum for a cast
              out_of_range <- which(is.na(binned_df[,col_index]))
              
              while(loop_flag == 0) {
                
                # Set plot x limits ----
                var_range <- diff(
                  range(
                    eval(
                      parse(
                        text = paste0("binned_df$", var[mm], "_", dir_vec[ii])
                      )
                    ), 
                    na.rm = TRUE)
                )
                
                if(var_range < var_range_min) {
                  set_xlim <- mean(var_range, na.rm = TRUE) + c(var_range - var_range_min/2, var_range + var_range_min/2)
                } else {
                  set_xlim <- NULL
                }
                
                # Plot and flag points ----
                plot(eval(parse(text = paste0("binned_df$", var[mm], "_", dir_vec[ii]))), 
                     y = binned_df$z_bin*-1, 
                     xlab = var[mm], 
                     ylab = z_var, 
                     type = 'l',
                     xlim = NULL, 
                     main = "Left-click on all points to be removed then press 'Esc'")
                points(eval(parse(text = paste0("binned_df$", var[mm], "_", dir_vec[ii]))), 
                       y = binned_df$z_bin*-1, 
                       xlab = var[mm], 
                       ylab = z_var,
                       xlim = NULL)
                new_flags <- identify(eval(parse(text = paste0("binned_df$", var[mm], "_", dir_vec[ii]))), 
                                      binned_df$z_bin*-1, 
                                      labels = row.names(binned_df))
                
                cast_index <- c(cast_index, new_flags)
                binned_df[cast_index, col_index] <- NA
                
                # User input
                if(tolower(readline("Accept profile (y) or remove additional points (n)?:")) == "y") {
                  loop_flag <- 1  
                }
              }
              
              assign(paste0("flag_", var[mm], "_", dir_vec[ii]), value = cast_index)
              
              # Interpolate missing values
              if(interpolation_method != "none") {
                print(paste0("Interpolating missing ", var[mm],  " values for ", deploy_id, " ", dir_vec[ii]))
                na_index <- which(
                  is.na(
                    eval(
                      parse(text = paste0("binned_df$", var[mm], "_", dir_vec[ii])
                      )
                    )
                  )
                )
                
                na_index <- na_index[!(na_index %in% out_of_range)]
                
                if(interpolation_method %in% c("rr", "unesco")) {
                  binned_df[na_index, col_index] <- oce::oceApprox(x = binned_df$z_bin, 
                                                                   y = eval(
                                                                     parse(
                                                                       text = paste0("binned_df$", var[mm], "_", dir_vec[ii])
                                                                     )
                                                                   ),
                                                                   method = interpolation_method)[na_index]
                } else if(interpolation_method == "linear") {
                  binned_df[na_index, col_index] <- approx(x = binned_df$z_bin, 
                                                           y = eval(
                                                             parse(
                                                               text = paste0("binned_df$", var[mm], "_", dir_vec[ii])
                                                             )
                                                           ),
                                                           method = interpolation_method)$y[na_index]
                }
              }
              loop_flag <- 0
            }
          }
          
          names(binned_df)[names(binned_df) == "z_bin"] <- z_var
          
          if(mm == 1) {
            out_df <- binned_df    
          } else {
            out_df <- out_df |> 
              dplyr::full_join(binned_df)
          }
          
        }
        
        # Append file name 
        out_df$file <- deploy_id
        
        # Write interpolated data to csv file
        out_path <- write.csv(out_df, 
                              file = here::here("output", 
                                                "manual_flag", 
                                                paste0(sub("\\_raw.*", "", deploy_id), "_flag_interp.csv")),
                              row.names = FALSE)
        
      } else {
        print(paste0("Insufficient or no data from ", deploy_id, " (index ", kk, " out of ", nrow(haul_metadata), ")"))
      }
    } else {
      print(paste0("Skipping ", here::here("output", "manual_flag", paste0(sub("\\_raw.*", "", deploy_id), "_flag_interp.csv")), " because it already exists."))
    }
  }
}